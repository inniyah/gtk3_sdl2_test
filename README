Scriptix -
See the file COPYING, which should have come with this distribution, for
information regarding the licensing terms and warranty for this software

Scriptix is a simple scripting language (not to be confused with a full-scale
programming language).  The intent of Scriptix is to allow easy, fast,
powerful scripting/plugin support for any application.

The list of current Scriptix features include:

	BASIC/Ruby-esque syntax
	Number and string data types
	Variables
	Nested scopes
	User and C functions
	Lists/arrays
	Garbage collection
	Classes w/ inheritance
	Exceptions
	While/until/do/for loops and blocks
	Ranges

Planned/future features include:

	Class scope (get rid of self variable in methods)
	Regular expressions
	Pre-emptive threading
	Re-entrant/threadable parsers

The one needing the most explanation is likely the pre-emptive threading.  The
idea there is that scripts, just like processes on a decent OS, should be
fully threadable in a safe way.  A single miscreant script should not be able
to deny other scripts the right to run, or (worse yet) lock up the controlling
process.  In other words, even if a user writes a script with an infinite
while loop or any such bug, your program will continue to run.

The other advantage is that blocking calls (be they system I/O calls, or
functions requesting and waiting for user response) similarly won't lock your
application.  Your script can run a simple function that asks a user for a yes
or no answer, and while it's waiting, the rest of the program can run.  No
callbacks (in the script) are needed, making the scripting experience a lot
simpler for the user.

Example of threading usage:

	answer = ask_yes_no ('Are you sure you want to do that?')
	if answer == 'yes' then
		ok = dialog ('Alright, here goes!')
	end

Now, in a normal scripting language, if your application ran a script similar
to this, the ask_yes_no() function would cause the application to lock up.  It
would wait for user input; but, since the hosting C application can't run again
until the script ends, it would dead-lock.

Even if you were using an event driven model, like GTK+ uses, for handling the
user widgets and responses, what happens if you want to run two scripts at
once?  Many popular interpreters are not re-entrant, and thus they will not
allow two or more concurrent scripts to execute.  Also, things like
disk/network I/O generally are not handled well even in event driven apps.
And, assuming that you *do* have a well behaved application, the C stack would
grow in size as more and more scripts are put on hold (waiting for a user who
went to the restroom, say, while the scripts are being triggered by outside
events), eventually causing a stack overflow and, thus, a crash.

Now, even if you have all of that taken care of (there are some languages that
avoid all the above issues well), there are also issues of speed.  If you are
running, say, a network application, every incoming packet may trigger the
running of a script.  Some of these scripts may be very long running.  You
must continue handling packets.  This means the script(s) need to be
interrupted, and control given back to your application's main logic loop, to
handle the incoming data.  Then, of course, you need to resume the scripts.

All of this is possible with pre-emptive script multi-tasking, which is the
most important goal of Scriptix.

As some notes, Scriptix is not based on a VM model.  A true VM language can
probably do everything Scriptix can, and (in many cases) do it much faster.
I have yet to see a freely available language that can boast all of these
features, and remain lite enough for use as scripting (not full-out
programming).  I'm sure there is one out there somewhere, tho, or perhaps
one will appear soon-ish.  Either way, a model based on a true VM would
likely prove better, and I would recommend you look at any such products
if given the chance, before deciding to use Scriptix for you project.  Of
all the project out there, Lua seems to closest in terms of architecture,
but its syntax and symantics aren't quite what they could be.

A block is merely a list of nodes that are evaluated in order.  Every bit
of executable code is thus some form of expression.  And, all expressions
must return a value (although it can be nil).  This means that code blocks,
such as if/while statements, return values.

Also, every block must return a value.  So, if you have a block of just 3
statements, with no return commands, what will its value be?  It will be
the last evaluated statement/node before the block returned.

This fact provides a powerful mechanism for writing code.  A very simple
example is the setting of variables:

	max = if a > b then a else b end

Granted, other languages provide even cleaner syntax for such a simple
operation, but the general idea of blocks returning values should be clear.
The if statement returned a value for the setting of max.  The two blocks,
the true case and the false case, each had a statement/node, with no return
commands.  However, the last executed statement in either block would be
returned.

Classes work fairly simply.  Every class is just a group of variables, much
like a nested scope.  You can get or set variables in a class, much like in
a scope.  However, classes also have a parent class.  When you try to get a
value from a class, and that variable does not exist, it then searches its
parent, then the parent's parent, and so on.  This allows simple but
usable inheritance.

It should also be noted that a class can inherit an instance of another
class.  Thus, you can make proxy instances of classes, or define wrapper
members for a class, without modifying the original instance.
